# 期末复习

## 第九、十章

### 体系结构的概念

软件体系结构={部件，连接件，配置}

一个软件系统的体系结构规定了系统计算部件和部件之间的交互。

### 各种体系结构风格的优缺点

#### 主程序/子程序

##### 简述

将系统组织成层次结构，主程序是一个调度器，在局部上子程序又是其下层子程序的调度器，负责调度各子程序执行。

##### 效果

优点

1. 流程清晰，易于理解。严格的层次分解使得系统的组织结构符合分治的思维方式，清晰描述流程。
2. 强控制性，更能控制程序的“正确性”

缺点：

1. 程序调用是一种强耦合，使得系统难以修改和复用
2. 程序调用的连接方式限制了部件之间的数据交互，可能会使得不同部件之间使用隐含的共享数据交流，产生不必要的公共耦合，进而破坏它控制“正确性”的能力。

#### 面向对象式

##### 简述

将系统组织成多个独立的对象，每个对象根据信息内聚的原则封装一定的信息，对外提供和其数据相一致的服务。

##### 效果

优点：

1. 内部实现的可修改性。
2. 易开发，易理解，易复用的组织结构。

以上两点也是模块化和信息隐藏带来的好处。

缺点：

1. 接口的耦合性。基于方法调用的连接机制无法消除接口的耦合性。
2. 标识的耦合性。一个对象要和另一个对象交互要持有它的标识
3. 副作用。引入了“副作用”，会影响程序的正确性控制。

#### 分层

##### 简述

根据不同的抽象层次，将系统组织为层次式结构，下层为上层提供服务，隐藏之下的细节，上层调用下层，为更上层提供服务，抽象层次逐渐变高。两个层次之间遵循成熟的稳定的标准的交互协议，跨层次和逆层次的连接都是禁止的。

##### 效果

优点

1. 设计机制清晰，易于理解
2. 支持并行开发
3. 更好的可复用性和可修改性。（层内可以替换）

缺点

1. 交互协议难以修改
2. 性能损失。多层的深入会带来性能问题
3. 难以确定层次的数量和粒度

#### MVC

##### 简述

把用户任务分解成三个部分：模型（承载数据和状态，执行业务逻辑），视图（负责用户交互和业务展现，接受用户行为），控制（系统的控制逻辑，调用业务逻辑和数据更新，决定业务展现）

##### 效果

优点

1. 易开发性。MVC 分别是业务逻辑，视图，控制三个任务的抽象，设计机制清晰，易于开发。
2. 视图和控制的可修改性。MVC 中模型是相对独立的，对视图和控制的修改不会影响到模型，而且业务逻辑通常比业务表现和控制更加稳定，因此MVC 有一定的可修改性优势。
3. 适用于网络开发的特征。

缺点

1. 复杂性。将用户任务分解成 MVC 一定程度上增加了复杂性。
2. 模型修改困难。

### 物理包设计原则

1. common closure principle（共同封闭原则）
   - 一起修改的类要放在一个包内（修改应该尽可能限制在一个包内）
   - 为 programmer 带来好处（开发者）
2. common reuse principle（共同重用原则）
   - 一个包内的类应该一起被重用（避免不必要的依赖）
   - 对维护者有利

CCP 和 CRP 之间是存在矛盾的，CCP 倾向于让包变大， CRP 倾向于让包变小，一个合适的方案是在不同的阶段对两个原则给予不同的权重，在项目还没有稳定的时候主要注意 CCP ， 在项目稳定之后主要注意 CRP

3. Reuse-Release Equivalency Principle（重用发布等价原则）
   - 重用的单位也是发布的单位
   - 让维护者更轻松

前三条都是关于内聚性的原则。

4. The Acyclic Dependencies Principle（无环依赖原则）
   - 自顶向下地组织包依赖关系
   - 包的依赖关系应该组成一个 DAG，不应该存在循环依赖
   - 解决循环依赖的方式1：抽出一个依赖的共同部分，共同依赖这个包
   - 解决循环依赖的方式2：抽出一个接口，倒置依赖
5. Stable Dependencies Principle（稳定依赖原则）
   - 依赖要指向稳定的包
   - stability：effort required to change the package
   - 稳定性度量：输入耦合度Ca,位于包外且依赖于包内的类的类的数目，输出耦合度Ce, 位于包内并依赖于包外的类的类的数目，不稳定度 I = Ce/(Ca + Ce)
6. Stable Abstractions Principle(稳定抽象原则)
   - 稳定的包应该尽量抽象
   - 抽象使得修改更加容易
   - 不稳定的包应该尽量具体
   - 抽象性度量：包内抽象类个数/总的类个数

后三个原则是关于耦合性的原则。

### 定义构件之间的接口

接口编写（必考）

1. 接口来源于哪？
   刺激响应序列和详细规格
   逻辑层接口，来源于需求，刺激响应序列。
   刺激是输入的参数，响应是返回值
   数据层接口来源于逻辑层代码，增删改查，逻辑层要什么就提供什么
2. 接口怎么定？
   刺激响应构成一个接口

### 集成

#### 集成策略

1. 大爆炸式

   - 一次性将所有模块组合在一起

2. 增量式

   - 自顶向下
     - 按照深度优先可以首先实现和验证一个完整的功能需求
     - 只需要顶端的一个驱动
     - 利于故障定位
     - 桩的开发量大
     - 低层组件验证被推迟，且测试不充分
   - 自底向上
     - 对低层组件较早验证
     - 低层组件开发可以并行
     - 利于故障定位
     - 桩的开发量小
     - 驱动开发量大
     - 对于高层的验证被推迟，不容易发现高层设计上的缺陷
   - 三明治式
   - 持续集成
     - 防止软件开发过程中出现无法集成和无法发布的状况
     - 有利于检查和发现集成缺陷

   Stub 和低层组件有相同的接口，但是逻辑简单，Driver 伪装成高层组件，调用本层组件